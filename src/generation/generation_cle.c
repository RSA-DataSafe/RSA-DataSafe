#include <gmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include "euclide.h"
#include <unistd.h>
#include <errno.h>
#include <sys/wait.h> 
#include <assert.h>
#include <sys/types.h>
#include <time.h>
#include "primalite.h"
#include "../structure/structure.h"
#include "bbs.h"
#include "generation_cle.h"

void calculPhi(mpz_t p, mpz_t q, mpz_t phi_n){
	//p-1
	mpz_t p1,q1;
   mpz_inits(p1,q1,NULL);
	mpz_sub_ui(p1,p,1);
	//p-1
	mpz_sub_ui(q1,q,1);
	//phi(n)=(p-1)(q-1)
	mpz_mul(phi_n,p1,q1);	
}


void calculerE(cle_publique *publique){

	//valeur aléatoire ,servira pour le choix de la valeur de e 

	mpz_t pgcd;
	mpz_init(pgcd);
	gmp_randstate_t etat ;
  gmp_randinit_default(etat);
  gmp_randseed_ui(etat, (unsigned)clock());
	do{
  mpz_urandomm(publique->e,etat,publique->n);
   mpz_gcd(pgcd,publique->e,publique->n);
	}while( mpz_cmp(publique->e, publique->n)>0  || mpz_cmp_ui(pgcd,1)!=0);


		
	}


void calculerD(cle_prive *prive, cle_publique *publique){
	mpz_t u,v;
	mpz_inits(u,v,NULL);

	euclide_etendu(u , v, prive->n, publique->e);
	mpz_t phi_n;
	mpz_init(phi_n);
	mpz_set(phi_n, prive->n);

	mpz_set(prive->d,v);
	mpz_set(prive->n,publique->n);
	mpz_clears(u,v,NULL);

	while(mpz_cmp_ui(prive->d, 0) < 0) {
		printf("here\n");
		mpz_add(prive->d, prive->d, phi_n);
	}
	mpz_clear(phi_n);
}
void GenererPQRSA(mpz_t p, mpz_t q, mpz_t n, int taille){
	 mpz_t t; 
         mpz_init(t);
         mpz_set_ui(t,40);int rps;
			

		for(;;){
			bbs(p,taille);
			if((mpz_cmp_ui(p,0)!=0 && miller_rabbin(p,t)==1)) break;
		
		}

		for(;;){
			bbs(q,taille-1);
			mpz_mul(n,p,q);
			if((mpz_cmp(p,q)!=0 && mpz_cmp_ui(q,0)!=0 &&  miller_rabbin(q,t)==1
	      && (mpz_sizeinbase(n,2)==2048))) break;
	
		}


	mpz_clear(t);
	}
void genere_cle(cle_publique *publique, cle_prive *prive, int taille){

	mpz_t p,q,n,phi_n,e,d;
	mpz_inits(p,q,n,phi_n,e,d, NULL);
	//génération de p et q
	GenererPQRSA(p,q,n,taille);
	mpz_t un;
	mpz_init(un);
	mpz_set_ui(un,1);
	

	
	//calcul de phi(n)
	calculPhi(p,q,phi_n);

	//mpz_set(prive->n,phi_n);

	// choix de l'exposant pulique e
	mpz_set(publique->n,phi_n);//n=ph_n
	calculerE(publique);
	
	mpz_set(publique->n,n);

	//pour avoir la valeur de phi(n) qui nous servira pour le calcul de d
	mpz_set(prive->n,phi_n);
	

	calculerD(prive, publique);
	mpz_set(prive->n,publique->n);
	printf("phi_n =  ");
	mpz_out_str(0,10,phi_n);
	printf("\n\n");

	printf("d =  ");
	mpz_out_str(0,10,prive->d);
	printf("\n\n");

	printf("e =  ");
	mpz_out_str(0,10,publique->e);
	printf("\n\n");

	printf("n =  ");
	mpz_out_str(0,10,publique->n);
	printf("\n\n");

	mpz_t test;
	mpz_set_str(d, "6323185963814703163456143704228189817345501249186818354203230864672149776077146573111818069565389295792657522486812905120456057877230285800793997090111640048096978211160675169752352070160390730854328781701905375177992729401133145270717094906899653058950024445504155350757255108618059435355655729210896582732121495573741884022896791984406012721046255304210189875338996608018017849242052413888792633945032526466731504634000922608285455966597448162913544799458711098124203392923092896004015403793473731102754366141356947423714549370776294228881805206802069687932158757800222049641023990593005874869829544545136304879667", 10);
	mpz_set_str(e, "1030563311229276755678186594759428678245265606551996788448230218659147033082954098419445853488377639812452554919102359274034557872131609100798709543209093491029427488912378501850145391501323530086788327499493911882992709743812271561839375313123820523547124370785029643635756521866641250496487108285042670900698760945609268816277186318244334667397157392837597831131828379804630832150474285921485887537838143188664963144495787049693520245133032937371631788277164792794109158325296976887373936559364806196640543920479486571434500424237043645511229827683995741620331722833785679724564932281838570117512182553376648468283", 10);
	mpz_set_str(n, "21266308685205577557728010066470707915150092616253736351983431663029911724298489844921630637633996036544833066259381992464489127559853753713085398395278081462358298953355145144313469525207381854609148008482089518652248628024021176643705919801080939408034004557064902314460362611678635348577466551714815730783929364806194216817660220867379577295027043037978638547967095855422155292227182548813943240696000797261686192310423183461556426710557602201402257911740590479048605237735588023244069182473980906573113289847154182026173029011741642902321213412279898982826783914845115457689837734540595441664949177334841262114729", 10);
	mpz_init_set_ui(test, 8);
	mpz_powm(test, test, e, n);
	mpz_powm(test, test, d, n);

	printf("test =  ");
	mpz_out_str(0,2,test);
	printf("\n\n");

	printf("taille de n : %ld\n\n", mpz_sizeinbase(publique->n, 2));

	mpz_set_str(prive->d, "6323185963814703163456143704228189817345501249186818354203230864672149776077146573111818069565389295792657522486812905120456057877230285800793997090111640048096978211160675169752352070160390730854328781701905375177992729401133145270717094906899653058950024445504155350757255108618059435355655729210896582732121495573741884022896791984406012721046255304210189875338996608018017849242052413888792633945032526466731504634000922608285455966597448162913544799458711098124203392923092896004015403793473731102754366141356947423714549370776294228881805206802069687932158757800222049641023990593005874869829544545136304879667", 10);
	mpz_set_str(prive->n, "21266308685205577557728010066470707915150092616253736351983431663029911724298489844921630637633996036544833066259381992464489127559853753713085398395278081462358298953355145144313469525207381854609148008482089518652248628024021176643705919801080939408034004557064902314460362611678635348577466551714815730783929364806194216817660220867379577295027043037978638547967095855422155292227182548813943240696000797261686192310423183461556426710557602201402257911740590479048605237735588023244069182473980906573113289847154182026173029011741642902321213412279898982826783914845115457689837734540595441664949177334841262114729", 10);
	mpz_set_str(publique->e, "1030563311229276755678186594759428678245265606551996788448230218659147033082954098419445853488377639812452554919102359274034557872131609100798709543209093491029427488912378501850145391501323530086788327499493911882992709743812271561839375313123820523547124370785029643635756521866641250496487108285042670900698760945609268816277186318244334667397157392837597831131828379804630832150474285921485887537838143188664963144495787049693520245133032937371631788277164792794109158325296976887373936559364806196640543920479486571434500424237043645511229827683995741620331722833785679724564932281838570117512182553376648468283", 10);
	mpz_set_str(publique->n, "21266308685205577557728010066470707915150092616253736351983431663029911724298489844921630637633996036544833066259381992464489127559853753713085398395278081462358298953355145144313469525207381854609148008482089518652248628024021176643705919801080939408034004557064902314460362611678635348577466551714815730783929364806194216817660220867379577295027043037978638547967095855422155292227182548813943240696000797261686192310423183461556426710557602201402257911740590479048605237735588023244069182473980906573113289847154182026173029011741642902321213412279898982826783914845115457689837734540595441664949177334841262114729", 10);

	printf("taille de n : %ld\n\n", mpz_sizeinbase(publique->n, 2));
	printf("taille de d : %ld\n\n", mpz_sizeinbase(prive->d, 2));
	printf("taille de e : %ld\n\n", mpz_sizeinbase(publique->e, 2));
	mpz_sub(prive->d, prive->d, phi_n);
	printf("taille de d : %ld\n\n", mpz_sizeinbase(prive->d, 2));
	mpz_set_str(prive->d, "6323185963814703163456143704228189817345501249186818354203230864672149776077146573111818069565389295792657522486812905120456057877230285800793997090111640048096978211160675169752352070160390730854328781701905375177992729401133145270717094906899653058950024445504155350757255108618059435355655729210896582732121495573741884022896791984406012721046255304210189875338996608018017849242052413888792633945032526466731504634000922608285455966597448162913544799458711098124203392923092896004015403793473731102754366141356947423714549370776294228881805206802069687932158757800222049641023990593005874869829544545136304879667", 10);

 
	mpz_clears(p,q,n,phi_n, NULL);
}


/*#include <gmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include "euclide.h"
#include <unistd.h>
#include <errno.h>
#include <sys/wait.h> 
#include <assert.h>
#include <sys/types.h>
#include <time.h>
#include "primalite.h"
#include "../structure/structure.h"
#include "bbs.h"
#include "generation_cle.h"

void calculPhi(mpz_t p, mpz_t q, mpz_t phi_n){
	//p-1
	mpz_t p1,q1;
	mpz_inits(p1,q1,NULL);
	mpz_set(p1,p);
	mpz_set(q1,q);
	mpz_sub_ui(p1,p1,1);
	//p-1
	mpz_sub_ui(q1,q1,1);
	//phi(n)=(p-1)(q-1)
	mpz_lcm(phi_n,p1,q1);	
	mpz_clears(p1,q1,NULL);
}


void calculerE(cle_publique *publique){
	mpz_t res, tmp;
	mpz_inits(res,tmp,NULL);
	mpz_set_ui(tmp, 3);
	mpz_gcd(res, tmp, publique->n);

	while (mpz_cmp_ui(res, 1)!= 0){
		mpz_add_ui(tmp, tmp, 2);
		mpz_gcd(res, tmp, publique->n);
	}

	mpz_set(publique->e, tmp);
	mpz_clears(res, tmp, NULL);	
		
	}

void calculerD(cle_prive *prive, cle_publique *publique){
	mpz_t u,v,gcd;
	mpz_inits(u,v,gcd,NULL);
	mpz_gcd(gcd, publique->e,prive->n );
	euclide_etendu(u , v, prive->n, publique->e);
	mpz_set(prive->d,v);
	mpz_set(prive->n,publique->n);
	mpz_clears(u,v,gcd,NULL);
	
}
void GenererPQRSA(mpz_t p, mpz_t q, mpz_t n, int taille){
	 mpz_t t; 
         mpz_init(t);
         mpz_set_ui(t,40);
			

		do{
			bbs(p,taille);
			mpz_nextprime(p,p);
			printf("dans q\n");
		}while(mpz_cmp_ui(p,0)<=0 || miller_rabbin(p,t)!=1  );

		do{
			bbs(q,taille-1);
			mpz_nextprime(q,q);
			mpz_mul(n,p,q);
			printf("dans q\n");
	
		}while( mpz_cmp(p,q)==0 || mpz_cmp_ui(q,0)<=0 || miller_rabbin(q,t)!=1|| (mpz_sizeinbase(n,2)!=2048));
		
	mpz_clear(t);
	}
void genere_cle(cle_publique *publique, cle_prive *prive, int taille){

	mpz_t p,q,n,phi_n;
	mpz_inits(p,q,n,phi_n, NULL);
	//génération de p et q
	GenererPQRSA(p,q,n,taille);
	mpz_mul(n,p,q);
	//calcul de phi(n)
	calculPhi(p,q,phi_n);
	
	mpz_set(publique->n,phi_n);
	
	// choix de l'exposant pulique e
	calculerE(publique);
	mpz_set(publique->n,n);
	
	//pour avoir la valeur de phi(n) qui nous servira pour le calcul de d
	mpz_set(prive->n,phi_n);

	calculerD(prive, publique);
	mpz_clears(p,q,n,phi_n, NULL);
}*/






